#!@BOURNE_SHELL@
#set -x

#search='grep -e FAIL -e COMPLETE'
# perl has more predictable flushing behavior
search='@PERL@ -e '"'"'$|=1;while (<>) { print if (/HARNESSERROR/ || /FAIL/ || /COMPLETE/); }'"'"
tail_f='@TAIL_FOLLOW@'

for arg in $*
do
 case $arg in 
  -u) 
   #search="$search | grep -v -i Known" ;;
   search="$search | @PERL@ -e '$|=1;while (<>) { next if (/KNOWN/i); print; }'" ;;
  *) echo "Usage: $0 [-u]" 1>&2
     echo " scans the compile.rpt and run.rpt files in the current directory" 1>&2
     echo " (or a logroot subdirectory) and output the failures" 1>&2
     echo " -u option limits output to 'unknown' failures" 1>&2
     exit 1
 esac
done

exist=
missing=
if test -f log; then
  exist="$exist log"
else
  if test -d logroot; then
    dir=`find logroot/* -type d -prune -print | sort | tail -1`
    echo Scanning files in $dir...
    cd $dir
    exec ../../checkfail $*
  fi
  echo 'ERROR: no log, compile.rpt or run.rpt files found!'
  exit 1
fi
if test -f compile.rpt; then
  exist="$exist compile.rpt"
else
  missing="$missing compile.rpt"
fi
if test -f run.rpt; then
  exist="$exist run.rpt"
else
  missing="$missing run.rpt"
fi

tailarg=
for file in $exist; do
  echo "==> $file <=="
  cat $file | eval $search
  tailarg=$file
done
@TAIL_FOLLOW_MULTI@ tailarg="$tailarg $missing"
if test -n "$tailarg" -a "$tailarg" != ' '; then
  $tail_f $tailarg 2>&1 | eval $search
fi
